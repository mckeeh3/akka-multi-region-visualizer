<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Akka Multi-Region Grid Demo - Help</title>
    <link rel="stylesheet" href="index.css" />
    <link rel="icon" href="favicon.ico" type="image/x-icon" />
    <style>
      /* Additional styles for help page */
      .help-container {
        max-width: 900px;
        margin: 20px auto;
        padding: 20px;
        background-color: rgba(15, 30, 60, 0.8);
        border-radius: 8px;
        box-shadow: 0 0 15px rgba(0, 150, 255, 0.3);
        backdrop-filter: blur(5px);
      }

      h1,
      h2 {
        color: #a7ecff;
        margin-bottom: 15px;
        text-shadow: 0 0 5px rgba(0, 200, 255, 0.5);
      }

      h1 {
        text-align: center;
        border-bottom: 1px solid #2a6ca5;
        padding-bottom: 10px;
      }

      p,
      ul {
        margin-bottom: 15px;
        line-height: 1.6;
      }

      ul {
        padding-left: 25px;
      }

      .key {
        display: inline-block;
        background-color: rgba(30, 50, 80, 0.9);
        padding: 2px 8px;
        border-radius: 4px;
        border: 1px solid #2a6ca5;
        margin: 0 3px;
        font-family: monospace;
        box-shadow: 0 0 5px rgba(0, 150, 255, 0.2);
      }

      .color-box {
        display: inline-block;
        width: 15px;
        height: 15px;
        margin: 0 5px;
        border-radius: 3px;
        vertical-align: middle;
      }

      .red {
        background-color: #ff5252;
      }
      .green {
        background-color: #4caf50;
      }
      .blue {
        background-color: #2196f3;
      }
      .orange {
        background-color: #f0950c;
      }

      .section {
        margin-bottom: 30px;
      }

      .back-link {
        display: block;
        text-align: center;
        margin-top: 20px;
        color: #a7ecff;
        text-decoration: none;
      }

      .back-link:hover {
        text-decoration: underline;
        text-shadow: 0 0 8px rgba(0, 200, 255, 0.8);
      }

      .diagram {
        background-color: rgba(10, 20, 40, 0.5);
        padding: 15px;
        border-radius: 6px;
        margin: 20px 0;
        border: 1px dashed #2a6ca5;
      }

      code {
        font-family: monospace;
        background-color: rgba(30, 50, 80, 0.9);
        padding: 2px 5px;
        border-radius: 3px;
      }
    </style>
  </head>
  <body>
    <div id="info-panel">
      <div>Region: <span id="region-url">Help Page</span></div>
      <div><a href="index.html" style="color: #a7ecff; text-decoration: none">Return to Grid</a></div>
    </div>

    <div class="help-container">
      <h1>Akka Multi-Region Grid Demo - Help</h1>

      <div class="section">
        <h2>How to Use the UI</h2>
        <p>
          The Akka Multi-Region Grid Demo provides a visual interface for interacting with a distributed grid of cells. Each cell can be in one of five states: default (empty) or color (red, green,
          blue, orange).
        </p>

        <h3>Basic Interactions:</h3>
        <ul>
          <li>
            <strong>Changing Cell States</strong>: Hover over any cell and press one of the following keys:
            <ul>
              <li><span class="key">r</span> - Set cell to <span class="color-box red"></span> red</li>
              <li><span class="key">g</span> - Set cell to <span class="color-box green"></span> green</li>
              <li><span class="key">b</span> - Set cell to <span class="color-box blue"></span> blue</li>
              <li><span class="key">o</span> - Set cell to <span class="color-box orange"></span> orange</li>
              <li><span class="key">d</span> - Set cell to default (empty)</li>
            </ul>
          </li>
          <li><strong>Cell Information</strong>: Cells display the elapsed time (in milliseconds) since they were last updated.</li>
          <li><strong>Grid Summary</strong>: The top of the grid shows a summary of the total number of cells in each state.</li>
          <li><strong>Connection Status</strong>: The top bar shows the current connection status and the server endpoint being used.</li>
        </ul>

        <h3>Grid Navigation:</h3>
        <p>
          The grid visualizer implements an <strong>infinite grid viewport</strong> concept. Think of the grid display as a window or viewport into a much larger grid that extends in all directions.
          The visible cells represent just a small portion of this larger grid, and you can navigate to view different grid locations.
        </p>
        <p>Your current position in the grid is displayed at the top of the grid area as "Grid Position: x=X, y=Y", where X and Y are the coordinates of the top-left cell of your viewport.</p>

        <h4>Navigation Commands:</h4>
        <p>You can navigate the grid using vim-like keyboard commands. Simply type a number followed by one of the command keys:</p>

        <h5>Absolute Positioning:</h5>
        <ul>
          <li><span class="key">100x</span> - Move to X-coordinate 100 (sets the left edge of the viewport)</li>
          <li><span class="key">-50y</span> - Move to Y-coordinate -50 (sets the top edge of the viewport)</li>
        </ul>

        <h5>Relative Movement:</h5>
        <ul>
          <li><span class="key">50h</span> - Move left 50 units (like vim's h key)</li>
          <li><span class="key">30j</span> - Move down 30 units (like vim's j key)</li>
          <li><span class="key">20k</span> - Move up 20 units (like vim's k key)</li>
          <li><span class="key">40l</span> - Move right 40 units (like vim's l key)</li>
        </ul>

        <p><strong>Notes on Navigation:</strong></p>
        <ul>
          <li>All movements are rounded to the nearest 10 units for alignment consistency</li>
          <li>The grid has boundaries at ±1,000,000 in all directions</li>
          <li>As you type a command, it appears in the info panel at the top</li>
          <li>Press <span class="key">Escape</span> to cancel a command in progress</li>
          <li>Relative movement commands (h/j/k/l) only accept positive numbers</li>
        </ul>

        <h3>Advanced Features:</h3>
        <ul>
          <li><strong>URL Parameters</strong>: You can customize the polling interval by adding <code>?interval=X</code> to the URL, where X is the interval in milliseconds (default is 2000ms).</li>
          <li><strong>Responsive Design</strong>: The grid automatically adjusts to your screen size, showing as many cells as possible while maintaining readability.</li>
        </ul>

        <h3>Box Selection for Multi-Cell Updates</h3>
        <p>The grid visualizer includes a powerful box selection feature that allows you to update multiple cells simultaneously:</p>

        <ol>
          <li>
            <strong>Enter Selection Mode</strong>: Hold down the <span class="key">Shift</span> key. You'll see a status message indicating "Selection mode active" and the cursor will change to a
            crosshair.
          </li>
          <li>
            <strong>Select a Region</strong>: While still holding <span class="key">Shift</span>, click on a cell that will be one corner of your selection, then move to the opposite corner. As you
            move the mouse pointer, you'll see cells highlighted with a dashed outline.
          </li>
          <li>
            <strong>Apply Color</strong>: With cells selected (still holding <span class="key">Shift</span>), press one of the color keys:
            <ul>
              <li><span class="key">r</span> - Set all selected cells to <span class="color-box red"></span> red</li>
              <li><span class="key">g</span> - Set all selected cells to <span class="color-box green"></span> green</li>
              <li><span class="key">b</span> - Set all selected cells to <span class="color-box blue"></span> blue</li>
              <li><span class="key">o</span> - Set all selected cells to <span class="color-box orange"></span> orange</li>
              <li><span class="key">d</span> - Clear all selected cells (default)</li>
            </ul>
          </li>
          <li><strong>Release Selection</strong>: After applying a color, or when you release the <span class="key">Shift</span> key, the selection will be cleared.</li>
        </ol>

        <br />
        <h3>Circular Multi-Cell Updates</h3>
        <p>
          Another way to perform multi-cell state changes is with a circular generation. Position the mouse pointer on any cell, then enter a number followed by one of the color keys. The mouse
          position is the center of a circle with a radius of the number entered (in cells). For example, <code>10r</code> will attempt to propagate the red color state to all cells within a circle of
          radius 10. There are two generation modes: <strong>span</strong> and <strong>fill</strong>.
        </p>
        <ul>
          <li>
            <strong>Fill Mode:</strong> If the center cell is empty, an attempt is made to set all empty cells within the circle to the specified color. Fill mode does not alter cells that are already
            in a different color state.
          </li>
          <li>
            <strong>Span Mode:</strong> If the center cell has a color, an attempt is made to update all other color state cells in the circle to match. Span mode does not alter cells that are empty.
          </li>
        </ul>
        <p><strong>How it works:</strong> When the center cell's state is altered, the corresponding Akka SDK entity emits eight events—one for each of its neighboring cells:</p>
        <pre style="font-size: 0.95em; background: #101825; color: #a7ecff; border-radius: 6px; padding: 8px; line-height: 1.2em">
            NW   N   NE
               \ | /
            W -- C -- E
               / | \
            SW   S   SE
        </pre>
        <p>
          An Akka SDK consumer component receives these events and sends a <em>fill</em> or <em>span</em> command to each neighbor entity. Each entity then decides whether to accept the command based
          on the command type and its own current state. This process can repeat recursively, allowing the color to propagate outward in a circle. As the neighbors receive the command, they may emit
          events for their own neighbors, and the process continues until the circle is fully propagated or until no more cells can be altered.
        </p>
        <p>This mechanism enables rapid propagation of color changes in circular patterns, supporting both contiguous fills and color state region spanning, depending on the starting cell's state.</p>

        <p><strong>Use Cases:</strong> This feature is particularly useful for:</p>
        <ul>
          <li>Testing multi-region replication with a large number of cells at once</li>
          <li>Creating patterns to visualize replication behavior</li>
          <li>Comparing replication times across different regions</li>
          <li>Stress-testing the system with many simultaneous updates</li>
        </ul>

        <p>
          <strong>Tip:</strong> When using box selection or circular generation in a multi-region deployment, try selecting large areas in one region and observe how quickly the changes propagate to
          clients connected to other regions. The elapsed time numbers will help you visualize the replication latency across your distributed system.
        </p>

        <h3>Understanding Elapsed Time Display:</h3>
        <p>
          Each color state cell displays a number representing the elapsed time in milliseconds (<code>elapsedMs</code>). This value provides a real-time measurement of replication and view update
          latency in the Akka SDK multi-region architecture. The process works as follows:
        </p>
        <ul>
          <li>
            <strong>Entity Update (Primary Region):</strong> When a client updates a grid cell, the primary Akka SDK entity for that cell (located in one region) sets its <code>updatedAt</code> state
            attribute to the current time.
          </li>
          <li>
            <strong>View Row Update (Primary Region):</strong> This entity state change triggers an update of the related view row, which sets its <code>viewAt</code> attribute to the current time.
            The <code>elapsedMs</code> value is calculated as <code>viewAt - updatedAt</code> and stored in the view row.
          </li>
          <li>
            <strong>Replication to Other Regions:</strong> Each entity state change is replicated to other regions. When the entity is updated in another region, it triggers a region-local view row
            update. <em>The entity's <code>updatedAt</code> is not changed during replication.</em>
          </li>
          <li>
            <strong>View Row Update (Replicated Region):</strong> The local view row in the replicated region is updated, setting its own <code>viewAt</code> to the current time and recalculating
            <code>elapsedMs = viewAt - updatedAt</code> using the original <code>updatedAt</code> from the primary region.
          </li>
          <li>
            <strong>Elapsed Time Meaning:</strong> As a result, the <code>elapsedMs</code> for each grid cell reflects the time taken to replicate the entity state change across regions and update the
            view row in each region. This includes cross-region replication time and any processing delay in updating the view.
          </li>
        </ul>
        <p>
          This approach provides a real-time visualization of distributed system latency and cross-region replication performance. When you see a cell's elapsed time, it shows how long it took for an
          update in the primary region to be reflected in the current region's view.
        </p>
      </div>

      <div class="section">
        <h2>How the Akka Service Works</h2>
        <p>This application demonstrates several key features of Akka's architecture and capabilities:</p>

        <div class="diagram">
          <pre>
┌─────────────────────────────────────────────────────────┐
│                      Web Browser                        │
│                                                         │
│  ┌─────────────┐     ┌─────────────┐    ┌────────────┐  │
│  │ HTTP Fetch  │     │ Server-Sent │    │ User Input │  │
│  │ (List View) │     │   Events    │    │ (Keyboard) │  │
│  └──────┬──────┘     └──────┬──────┘    └──────┬─────┘  │
└─────────┼─────────────────────────────────────┼─────────┘
          │                   │                 │
          ▼                   ▼                 ▼
┌─────────────────────────────────────────────────────────┐
│                     Akka HTTP Server                    │
│                                                         │
│  ┌─────────────┐     ┌─────────────┐    ┌────────────┐  │
│  │  View List  │     │ View Stream │    │   Update   │  │
│  │  Endpoint   │     │  Endpoint   │    │  Endpoint  │  │
│  └──────┬──────┘     └──────┬──────┘    └──────┬─────┘  │
└─────────┼─────────────────────────────────────┼─────────┘
          │                   │                 │
          ▼                   ▼                 ▼
┌─────────────────────────────────────────────────────────┐
│                    Akka Component System                │
│                                                         │
│  ┌─────────────┐                        ┌────────────┐  │
│  │ SensorView  │◄───────────────────────┤SensorEntity│  │
│  │  (View)     │                        │ (Entity)   │  │
│  └─────────────┘                        └────────────┘  │
│                                                         │
└─────────────────────────────────────────────────────────┘
          </pre>
        </div>

        <h3>Key Components:</h3>
        <ul>
          <li><strong>Event Sourcing</strong>: Each cell is an Event Sourced Entity (<code>SensorEntity</code>) that maintains its state through events.</li>
          <li>
            <strong>Views</strong>: The <code>SensorView</code> component provides two ways to access the data:
            <ul>
              <li><code>getViewList</code>: Returns a snapshot of all sensors as a list</li>
              <li><code>getViewStream</code>: Provides a real-time stream of sensor updates</li>
            </ul>
          </li>
          <li>
            <strong>HTTP API</strong>: The <code>SensorEndpoint</code> exposes these capabilities through HTTP:
            <ul>
              <li><code>/sensor/view/list</code>: HTTP endpoint to get all sensors</li>
              <li><code>/sensor/view/stream</code>: Server-Sent Events (SSE) endpoint for real-time updates</li>
              <li><code>/sensor/update-status</code>: HTTP PUT endpoint to update a sensor's status</li>
            </ul>
          </li>
          <li>
            <strong>Client-Side Integration</strong>: The JavaScript client uses:
            <ul>
              <li>HTTP fetch for initial state and polling updates</li>
              <li>EventSource API for real-time SSE updates</li>
              <li>HTTP PUT requests to send updates to the server</li>
            </ul>
          </li>
        </ul>

        <h3>Technical Details:</h3>
        <ul>
          <li>
            <strong>Optimizations</strong>:
            <ul>
              <li>Cell updates only occur when the status actually changes</li>
              <li>The server avoids persisting events when setting a default cell back to default</li>
              <li>Both polling and streaming are used for maximum reliability</li>
            </ul>
          </li>
          <li>
            <strong>Scalability</strong>: This architecture can scale to handle thousands of concurrent users and cells, as Akka's distributed nature allows entities to be spread across multiple
            nodes.
          </li>
        </ul>
      </div>

      <a href="index.html" class="back-link">Return to Grid Demo</a>
    </div>
  </body>
</html>
